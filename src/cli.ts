import * as path from 'path';
import * as yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

type Camel<T extends string> = T extends `${infer Left}-${infer Right}`
	? Camel<`${Left}${Capitalize<Right>}`>
	: T;

type CamelKeys<T> = {
	[K in keyof T as K extends string ? Camel<K> : K]: T[K];
};

export default async function parseCli(argv?: string | readonly string[]) {
	const parsedRaw = await yargs
		.options({
			'api-token': {
				describe: 'ttoken to use for Livepeer API',
				demandOption: true,
				type: 'string'
			},
			'asset-name': {
				describe: 'name for the asset created in Livepeer.com API',
				type: 'string'
			},
			'nft-metadata': {
				describe:
					'additional JSON metadata to override default generated by Livepeer for the NFT',
				type: 'string',
				default: '{}'
			},
			'api-host': {
				describe: 'the endpoint to use for the Livepeer API',
				type: 'string',
				default: 'https://livepeer.com'
			},
			filename: {
				describe: 'file to upload as nft',
				demandOption: true,
				type: 'string'
			}
		})
		.usage(
			`
  Video NFT

  Mint a video NFT in 1 command with Livepeer.
  `
		)
		.env('LP_')
		.strict(process.env.NODE_ENV !== 'test')
		.help()
		.parse((argv as any) ?? hideBin(process.argv));
	if (!parsedRaw.filename) {
		throw new Error('Usage: video-nft <filename>');
	}
	return {
		...(parsedRaw as CamelKeys<typeof parsedRaw>),
		assetName: parsedRaw.assetName ?? path.basename(parsedRaw.filename)
	};
}
