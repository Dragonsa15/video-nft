import * as path from 'path';
import * as fs from 'fs';

import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

type Camel<T extends string> = T extends `${infer Left}-${infer Right}`
	? Camel<`${Left}${Capitalize<Right>}`>
	: T;

type CamelKeys<T> = {
	[K in keyof T as K extends string ? Camel<K> : K]: T[K];
};

export default async function parseCli(argv?: string | readonly string[]) {
	const parsedRaw = await yargs
		.command('$0 <filename>', '1-command mint a video NFT')
		.positional('filename', {
			describe: 'file to upload as an NFT',
			demandOption: true,
			type: 'string'
		})
		.options({
			'api-token': {
				describe: 'ttoken to use for Livepeer API',
				demandOption: true,
				type: 'string'
			},
			'asset-name': {
				describe: 'name for the asset created in Livepeer.com API',
				type: 'string'
			},
			'nft-metadata': {
				describe:
					'additional JSON metadata to override default generated by Livepeer for the NFT',
				type: 'string',
				default: '{}'
			},
			'api-host': {
				describe: 'the endpoint to use for the Livepeer API',
				type: 'string',
				default: 'https://livepeer.com'
			},
			'mint-nft': {
				describe: 'show link to experimental NFT minter at the end',
				type: 'boolean',
				default: false
			}
		})
		.usage(
			`
	Video NFT

  Mint a video NFT in 1 command with Livepeer.

	Usage: video-nft <filename> [options]`
		)
		.env('LP_')
		.help()
		.parse((argv as any) ?? hideBin(process.argv));
	if (!fs.existsSync(parsedRaw.filename)) {
		throw new Error(`File ${parsedRaw.filename} does not exist`);
	}
	if (fs.existsSync(parsedRaw.nftMetadata)) {
		parsedRaw.nftMetadata = fs.readFileSync(parsedRaw.nftMetadata, 'utf8');
	}
	try {
		if (parsedRaw.nftMetadata != '{}') {
			const metadata = JSON.parse(parsedRaw.nftMetadata);
			console.log(
				`Using metadata:\n${JSON.stringify(metadata, null, 2)}`
			);
		}
	} catch (e) {
		throw new Error(`Invalid JSON in nft-metadata: ${e}`);
	}
	return {
		...(parsedRaw as CamelKeys<typeof parsedRaw>),
		assetName: parsedRaw.assetName ?? path.basename(parsedRaw.filename)
	};
}
